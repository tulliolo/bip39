#!/usr/bin/python3
#
#   Copyright (C) 2022 Tullio Loffredo, @tulliolo
#
#   It is subject to the license terms in the LICENSE file found in the top-level
#   directory of this distribution.
#
#   No part of this software, including this file, may be copied, modified,
#   propagated, or distributed except according to the terms contained in the
#   LICENSE file.
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#   FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE
#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
"""
A module implementing the mnemonic as defined in bip39 specs:

https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
"""
import hashlib
import logging
import math
from typing import Iterable

from tulliolo.bip39.entropy import Entropy, ENTROPY_SIZE_RANGE, ENTROPY_SIZE_STEP
from tulliolo.bip39.wordlist import wordlist

WORD_SIZE = 11  # bits

WORD_COUNT_ALL = tuple(
    math.ceil(entropy_size / WORD_SIZE) for entropy_size in ENTROPY_SIZE_RANGE
)

CHECKSUM_SIZE_ALL = tuple(
    word_count*WORD_SIZE - entropy_size
    for word_count, entropy_size in zip(WORD_COUNT_ALL, ENTROPY_SIZE_RANGE)
)

LOGGER = logging.getLogger(__name__)


class Checksum:
    """
    The checksum, as defined in bip39 specs:

    https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
    """
    def __init__(self, entropy: Entropy):
        """
        Builds a new checksum instance.
        :param entropy: the entropy
        """
        if not isinstance(entropy, Entropy):
            LOGGER.error("invalid entropy type")
            raise TypeError(
                "invalid entropy type",
                f"expected: {Entropy}",
                f"obtained: {type(entropy)}"
            )

        self.__size = CHECKSUM_SIZE_ALL[
            ENTROPY_SIZE_RANGE.index(len(entropy))
        ]

        entropy_hash = hashlib.sha256(entropy.value).digest()
        self.__value = entropy_hash[0] >> (8 - self.__size)

    def __eq__(self, other):
        if not isinstance(other, Checksum):
            LOGGER.warning(
                "cannot compare objects of different types"
            )
            return False

        return (
            self.__value == other.__value and
            len(self) == len(other)
        )

    def __len__(self) -> int:
        """
        Returns the checksum size in bits.
        :return:
        """
        return self.__size

    @property
    def value(self) -> int:
        """
        The checksum value.
        :return:
        """
        return self.__value


class Mnemonic:
    """
    The mnemonic, as defined in bip39 specs:

    https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
    """
    _create_key = object()

    def __init__(self, create_key, entropy: Entropy):
        """
        Builds a new mnemonic instance. It cannot be directly invoked (see from_value and from_entropy methods).
        :param create_key: a key for this class, locking the direct invocation of the constructor
        :param entropy: the entropy
        """
        assert create_key == self._create_key, \
            "mnemonic must be created by import_value or from_entropy"

        self._entropy = entropy
        self._checksum = Checksum(entropy)

    def __eq__(self, other) -> bool:
        if not isinstance(other, Mnemonic):
            try:
                other = Mnemonic.from_value(other)
            except Exception as e:
                LOGGER.warning(
                    f"cannot convert '{other}' into {Mnemonic} | "
                    f"{' | '.join(e.args)}"
                )
                return False

        return self._entropy == other._entropy and self._checksum == other._checksum

    def __len__(self) -> int:
        """
        Returns the number of words.
        :return:
        """
        return WORD_COUNT_ALL[
            ENTROPY_SIZE_RANGE.index(len(self._entropy))
        ]

    @classmethod
    def from_value(cls, value: str | bytes | bytearray | Iterable[str], fix_checksum: bool = False) -> "Mnemonic":
        """
        Imports a mnemonic value.
        :param fix_checksum: if set, corrects the checksum (and the last word);
        useful e.g. when the mnemonic is generated by rolling dices.
        :param value: a string or bytes or iterable of strings representing the mnemonic value
        :return:
        """
        if isinstance(value, str):
            value = value.split()
        elif isinstance(value, bytes | bytearray):
            value = value.decode("utf-8").split()
        elif not isinstance(value, Iterable):
            LOGGER.error("invalid mnemonic type")
            raise TypeError(
                "invalid mnemonic type",
                "mnemonic must be of type string or iterable of strings"
            )

        value = tuple([str(v) for v in value])
        if len(value) not in WORD_COUNT_ALL:
            LOGGER.error("invalid mnemonic size")
            raise ValueError(
                "invalid mnemonic size",
                f"expected: {'/'.join([str(num) for num in WORD_COUNT_ALL])}",
                f"obtained: {len(value)}"
            )

        LOGGER.debug("index -> word")
        sequence = 0
        for word in value:
            try:
                wid = wordlist.index(word)
                LOGGER.debug(f"{wid:4}  -> {word}")
            except ValueError as e:
                LOGGER.error(f"invalid mnemonic | {str(e)}")
                raise ValueError(
                    "invalid mnemonic",
                    f"word '{word}' is not in dictionary"
                ) from None

            sequence = (sequence << WORD_SIZE) | wid

        sequence_size = len(value) * WORD_SIZE  # bits
        checksum_size = sequence_size // ENTROPY_SIZE_STEP  # bits
        entropy_size = sequence_size - checksum_size  # bits
        LOGGER.debug(f"checksum size = {checksum_size} | entropy size = {entropy_size}")

        entropy = (sequence >> checksum_size).to_bytes(entropy_size // 8, byteorder="big")
        checksum = sequence & (2 ** checksum_size - 1)

        mnemonic = cls(cls._create_key, Entropy.from_value(entropy))
        if not fix_checksum and mnemonic._checksum.value != checksum:
            LOGGER.error("invalid checksum")
            raise ValueError(
                "invalid checksum",
                f"expected: {mnemonic._checksum.value}",
                f"obtained: {checksum}"
            )

        return mnemonic

    @classmethod
    def from_entropy(cls, entropy: Entropy) -> "Mnemonic":
        """
        Generates a new mnemonic object from the specified entropy.
        :param entropy: the entropy used to generate the mnemonic
        :return: a new mnemonic object
        """
        if not isinstance(entropy, Entropy):
            LOGGER.error("invalid entropy type")
            raise TypeError(
                "invalid entropy type",
                "entropy must be of type Entropy"
            )

        return cls(cls._create_key, entropy)

    @property
    def entropy(self) -> Entropy:
        """
        The entropy.
        :return:
        """
        return self._entropy

    @property
    def checksum(self) -> Checksum:
        """
        The checksum.
        :return:
        """
        return self._checksum

    @property
    def value(self) -> str:
        """
        the mnemonic value.
        :return:
        """
        entropy_size = len(self._entropy)  # bits
        checksum_size = len(self._checksum)  # bits
        sequence_size = entropy_size + checksum_size  # bits

        sequence = \
            (
                    int.from_bytes(self._entropy.value, byteorder="big") << checksum_size
            ) | self._checksum.value

        word_count = sequence_size // WORD_SIZE
        return " ".join([
            str(
                wordlist[
                    sequence >> ((word_count - i - 1) * WORD_SIZE) & (2 ** WORD_SIZE - 1)
                    ]
            ) for i in range(word_count)
        ])

    @property
    def info(self) -> dict:
        """
        A descriptor for this mnemonic instance.
        :return:
        """
        return {
            "entropy": self._entropy.value.hex(),
            "checksum": hex(self._checksum.value)[2:],
            "mnemonic": self.value,
        }
